<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<title>Rasterkarte â€“ Generator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
  html, body { height:100%; margin:0; }
  #map { width:100vw; height:100vh; }
</style>
</head>
<body>

<div id="map"></div>

<script>
/* ======================================================
   GRUNDKONFIGURATION
====================================================== */
const IMG_WIDTH  = 3876;
const IMG_HEIGHT = 3890;

const GRID_W = 120;
const GRID_H = 120;

const CELL_W = IMG_WIDTH  / GRID_W;
const CELL_H = IMG_HEIGHT / GRID_H;

// Feinjustage (Pixel, +/- erlaubt)
const OFFSET_X = -17;
const OFFSET_Y = -3;

/* ======================================================
   LEAFLET MAP
====================================================== */
window.addEventListener("load", () => {

  const map = L.map("map", {
    crs: L.CRS.Simple,
    minZoom: -2,
    maxZoom: 3
  });

  const bounds = [[0,0],[IMG_HEIGHT,IMG_WIDTH]];
  L.imageOverlay("map.png", bounds).addTo(map);
  map.fitBounds(bounds);

  const zoneLayer = L.layerGroup().addTo(map);

  /* ======================================================
     SHAPE TEMPLATES (ZELLEN)
     Koordinaten: [x, y]
  ====================================================== */
  const SHAPES = {
    quadrat: [
      [0,0],[1,0],
      [0,1],[1,1]
    ],

    L1: [
      [0,0],
      [0,1],[1,1]
    ],
    TForm: [
      [1,0],[2,0],
      [0,1],[1,1],[2,1],[3,1]
    ],
    kreuz: [
      [1,0],[2,0],
      [0,1],[1,1],[2,1],[3,1],
      [0,2],[1,2],[2,2],[3,2],
      [1,3],[2,3]
    ]
  };

  /* ======================================================
     HILFSFUNKTIONEN
  ====================================================== */
  function rotateCells(cells, deg) {
    const r = ((deg % 360) + 360) % 360;
    let out = cells.map(([x,y]) => {
      if (r === 0)   return [ x,  y];
      if (r === 90)  return [ y, -x];
      if (r === 180) return [-x, -y];
      if (r === 270) return [-y,  x];
    });
    const minX = Math.min(...out.map(p => p[0]));
    const minY = Math.min(...out.map(p => p[1]));
    return out.map(([x,y]) => [x - minX, y - minY]);
  }

  function shapeSize(cells) {
    return {
      w: Math.max(...cells.map(c => c[0])) + 1,
      h: Math.max(...cells.map(c => c[1])) + 1
    };
  }

  const key = (x,y) => `${x},${y}`;

  function cellsToSegments(cells, gx, gy) {
    const filled = new Set(cells.map(c => key(gx+c[0], gy+c[1])));
    const segs = [];

    for (const [cx,cy] of cells) {
      const x = gx + cx, y = gy + cy;
      if (!filled.has(key(x, y-1))) segs.push([[x,y],[x+1,y]]);
      if (!filled.has(key(x+1,y))) segs.push([[x+1,y],[x+1,y+1]]);
      if (!filled.has(key(x,y+1))) segs.push([[x+1,y+1],[x,y+1]]);
      if (!filled.has(key(x-1,y))) segs.push([[x,y+1],[x,y]]);
    }
    return segs;
  }

  function segmentsToRing(segs) {
    const map = new Map();
    for (const [[x1,y1],[x2,y2]] of segs) {
      const k = key(x1,y1);
      if (!map.has(k)) map.set(k, []);
      map.get(k).push([x2,y2]);
    }

    const start = [...map.keys()]
      .map(k => k.split(",").map(Number))
      .sort((a,b) => (a[1]-b[1])||(a[0]-b[0]))[0];

    const ring = [start];
    let cur = start;

    while (true) {
      const outs = map.get(key(cur[0],cur[1]));
      if (!outs) break;
      const prev = ring.length > 1 ? ring[ring.length-2] : null;
      let next = outs[0];
      if (outs.length > 1 && prev &&
          outs[0][0] === prev[0] && outs[0][1] === prev[1]) {
        next = outs[1];
      }
      if (next[0] === start[0] && next[1] === start[1]) break;
      ring.push(next);
      cur = next;
    }
    return ring;
  }

  function ringToLatLngs(ring) {
    return ring.map(([x,y]) => [
      OFFSET_Y + y * CELL_H,
      OFFSET_X + x * CELL_W
    ]);
  }

  /* ======================================================
     ZEICHNEN EINER FORM (EIN POLYGON)
  ====================================================== */
  function drawPlacement({shape, rot, gx, gy, color}) {
    const cells = rotateCells(SHAPES[shape], rot);
    const segs  = cellsToSegments(cells, gx, gy);
    const ring  = segmentsToRing(segs);
    const poly  = L.polygon(ringToLatLngs(ring), {
      color:"#000",
      weight:2,
      fillColor:color,
      fillOpacity:0.35
    }).addTo(zoneLayer);

    return shapeSize(cells);
  }

  /* ======================================================
     PATTERN / GENERATOR
  ====================================================== */
  const COLORS = {
    A:"#6aa9ff",
    B:"#ff6a6a"
  };

  const ROW_TYPES = {
    R1: [
      {shape:"L1", rot:-90,  repeat:1,  color:COLORS.A},
      {shape:"TForm", rot:0, repeat:12, color:COLORS.B}
      ]
  };

  const ROW_PLAN = [
    {rowType:"R1", repeatRows:10}
  ];

  /* ======================================================
     RENDER
  ====================================================== */
  let gy = 0;
  for (const block of ROW_PLAN) {
    for (let r=0;r<block.repeatRows;r++) {
      let gx = 0, rowH = 0;
      for (const item of ROW_TYPES[block.rowType]) {
        for (let i=0;i<item.repeat;i++) {
          const size = drawPlacement({...item, gx, gy});
          gx += size.w;
          rowH = Math.max(rowH, size.h);
        }
      }
      gy += rowH;
    }
  }

});
</script>
</body>
</html>
